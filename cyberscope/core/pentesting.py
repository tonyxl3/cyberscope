import socket
import ssl
import threading
import time
from datetime import datetime
from urllib.parse import urlparse, parse_qs, urlencode
import requests
from bs4 import BeautifulSoup
import re

from .utils import FINDINGS, logger


def escanear_puertos(host: str, puertos: list = None, timeout: int = 1) -> dict:
    """
    Escanea puertos TCP en un host específico.
    
    Args:
        host: Host o IP a escanear
        puertos: Lista de puertos a escanear (por defecto puertos comunes)
        timeout: Timeout para cada conexión
        
    Returns:
        Diccionario con puertos abiertos y cerrados
    """
    if puertos is None:
        # Puertos comunes
        puertos = [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 993, 995, 1433, 1521, 3306, 3389, 5432, 5900, 8080, 8443]
    
    FINDINGS.append(f"[PORTSCAN] Iniciando escaneo de puertos en {host}")
    
    resultados = {
        "host": host,
        "abiertos": [],
        "cerrados": [],
        "filtrados": []
    }
    
    def escanear_puerto(puerto):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            resultado = sock.connect_ex((host, puerto))
            
            if resultado == 0:
                resultados["abiertos"].append(puerto)
                FINDINGS.append(f"[PORT_OPEN] {host}:{puerto} - ABIERTO")
                
                # Intentar banner grabbing
                try:
                    sock.send(b"HEAD / HTTP/1.0\r\n\r\n")
                    banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
                    if banner:
                        FINDINGS.append(f"[BANNER] {host}:{puerto} - {banner[:100]}")
                except:
                    pass
            else:
                resultados["cerrados"].append(puerto)
                
            sock.close()
            
        except socket.gaierror:
            FINDINGS.append(f"[PORTSCAN_ERROR] No se pudo resolver {host}")
        except Exception as e:
            resultados["filtrados"].append(puerto)
            logger.debug(f"Puerto {puerto} filtrado o error: {e}")
    
    # Escaneo con hilos para mayor velocidad
    threads = []
    for puerto in puertos:
        thread = threading.Thread(target=escanear_puerto, args=(puerto,))
        threads.append(thread)
        thread.start()
        
        # Limitar hilos concurrentes
        if len(threads) >= 50:
            for t in threads:
                t.join()
            threads = []
    
    # Esperar hilos restantes
    for thread in threads:
        thread.join()
    
    FINDINGS.append(f"[PORTSCAN_RESULT] {host} - Abiertos: {len(resultados['abiertos'])}, Cerrados: {len(resultados['cerrados'])}")
    return resultados


def detectar_vulnerabilidades_web(url: str) -> dict:
    """
    Detecta vulnerabilidades web comunes.
    
    Args:
        url: URL a analizar
        
    Returns:
        Diccionario con vulnerabilidades encontradas
    """
    FINDINGS.append(f"[VULNSCAN] Iniciando detección de vulnerabilidades en {url}")
    
    vulnerabilidades = {
        "sql_injection": [],
        "xss": [],
        "directory_traversal": [],
        "command_injection": [],
        "information_disclosure": []
    }
    
    try:
        # Test básico de conectividad
        response = requests.get(url, timeout=10)
        
        # === SQL Injection básico ===
        sql_payloads = ["'", "1' OR '1'='1", "'; DROP TABLE users; --", "1' UNION SELECT NULL--"]
        
        for payload in sql_payloads:
            try:
                test_url = f"{url}?id={payload}"
                r = requests.get(test_url, timeout=5)
                
                # Buscar errores SQL comunes
                sql_errors = [
                    "mysql_fetch_array", "ORA-01756", "Microsoft OLE DB Provider",
                    "PostgreSQL query failed", "SQLite error", "mysql_num_rows",
                    "Warning: mysql", "valid MySQL result", "MySqlClient"
                ]
                
                for error in sql_errors:
                    if error.lower() in r.text.lower():
                        vulnerabilidades["sql_injection"].append({
                            "payload": payload,
                            "error": error,
                            "url": test_url
                        })
                        FINDINGS.append(f"[VULN_SQL] Posible SQL Injection: {test_url}")
                        break
                        
            except:
                continue
        
        # === XSS básico ===
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "'\"><script>alert('XSS')</script>"
        ]
        
        for payload in xss_payloads:
            try:
                test_url = f"{url}?search={payload}"
                r = requests.get(test_url, timeout=5)
                
                if payload in r.text:
                    vulnerabilidades["xss"].append({
                        "payload": payload,
                        "url": test_url
                    })
                    FINDINGS.append(f"[VULN_XSS] Posible XSS reflejado: {test_url}")
                    
            except:
                continue
        
        # === Directory Traversal ===
        traversal_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "....//....//....//etc/passwd"
        ]
        
        for payload in traversal_payloads:
            try:
                test_url = f"{url}?file={payload}"
                r = requests.get(test_url, timeout=5)
                
                if "root:" in r.text or "[drivers]" in r.text:
                    vulnerabilidades["directory_traversal"].append({
                        "payload": payload,
                        "url": test_url
                    })
                    FINDINGS.append(f"[VULN_TRAVERSAL] Posible Directory Traversal: {test_url}")
                    
            except:
                continue
        
        # === Command Injection ===
        cmd_payloads = [
            "; ls -la",
            "| whoami",
            "&& dir",
            "`id`"
        ]
        
        for payload in cmd_payloads:
            try:
                test_url = f"{url}?cmd={payload}"
                r = requests.get(test_url, timeout=5)
                
                cmd_indicators = ["uid=", "gid=", "groups=", "Directory of", "total "]
                for indicator in cmd_indicators:
                    if indicator in r.text:
                        vulnerabilidades["command_injection"].append({
                            "payload": payload,
                            "url": test_url
                        })
                        FINDINGS.append(f"[VULN_CMD] Posible Command Injection: {test_url}")
                        break
                        
            except:
                continue
        
        # === Information Disclosure ===
        info_paths = [
            "/.env", "/config.php", "/wp-config.php", "/.git/config",
            "/admin", "/phpmyadmin", "/backup.sql", "/database.sql"
        ]
        
        base_url = url.rstrip('/')
        for path in info_paths:
            try:
                test_url = f"{base_url}{path}"
                r = requests.get(test_url, timeout=5)
                
                if r.status_code == 200 and len(r.text) > 100:
                    vulnerabilidades["information_disclosure"].append({
                        "path": path,
                        "url": test_url,
                        "status": r.status_code
                    })
                    FINDINGS.append(f"[VULN_INFO] Información sensible expuesta: {test_url}")
                    
            except:
                continue
                
    except Exception as e:
        FINDINGS.append(f"[VULNSCAN_ERROR] Error en detección de vulnerabilidades: {e}")
        logger.error(f"Error en vulnscan: {e}")
    
    total_vulns = sum(len(v) for v in vulnerabilidades.values())
    FINDINGS.append(f"[VULNSCAN_RESULT] {total_vulns} vulnerabilidades potenciales encontradas")
    
    return vulnerabilidades


def analizar_certificado_ssl(hostname: str, port: int = 443) -> dict:
    """
    Analiza el certificado SSL de un servidor.
    
    Args:
        hostname: Nombre del host
        port: Puerto SSL (por defecto 443)
        
    Returns:
        Diccionario con información del certificado
    """
    FINDINGS.append(f"[SSL_ANALYSIS] Analizando certificado SSL de {hostname}:{port}")
    
    cert_info = {}
    
    try:
        # Crear contexto SSL
        context = ssl.create_default_context()
        
        # Conectar y obtener certificado
        with socket.create_connection((hostname, port), timeout=10) as sock:
            with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                cert = ssock.getpeercert()
                
                # Información básica del certificado
                cert_info = {
                    "subject": dict(x[0] for x in cert.get('subject', [])),
                    "issuer": dict(x[0] for x in cert.get('issuer', [])),
                    "version": cert.get('version'),
                    "serial_number": cert.get('serialNumber'),
                    "not_before": cert.get('notBefore'),
                    "not_after": cert.get('notAfter'),
                    "signature_algorithm": cert.get('signatureAlgorithm'),
                    "san": cert.get('subjectAltName', [])
                }
                
                # Verificar fechas
                not_after = datetime.strptime(cert.get('notAfter'), '%b %d %H:%M:%S %Y %Z')
                days_until_expiry = (not_after - datetime.now()).days
                
                if days_until_expiry < 30:
                    FINDINGS.append(f"[SSL_WARNING] Certificado expira en {days_until_expiry} días")
                
                # Información de logging
                FINDINGS.append(f"[SSL_CERT] Emisor: {cert_info['issuer'].get('organizationName', 'N/A')}")
                FINDINGS.append(f"[SSL_CERT] Sujeto: {cert_info['subject'].get('commonName', 'N/A')}")
                FINDINGS.append(f"[SSL_CERT] Válido hasta: {cert_info['not_after']}")
                FINDINGS.append(f"[SSL_CERT] Días hasta expiración: {days_until_expiry}")
                
                # Verificar algoritmo de firma
                sig_alg = cert_info.get('signature_algorithm', '').lower()
                if 'sha1' in sig_alg:
                    FINDINGS.append(f"[SSL_WARNING] Algoritmo de firma débil: {sig_alg}")
                
                # Verificar SAN
                san_list = [name[1] for name in cert_info['san'] if name[0] == 'DNS']
                if san_list:
                    FINDINGS.append(f"[SSL_SAN] Nombres alternativos: {', '.join(san_list)}")
                
    except ssl.SSLError as e:
        FINDINGS.append(f"[SSL_ERROR] Error SSL: {e}")
        cert_info["error"] = str(e)
    except Exception as e:
        FINDINGS.append(f"[SSL_ERROR] Error analizando certificado: {e}")
        cert_info["error"] = str(e)
    
    return cert_info


def fuzzing_parametros_web(url: str, parametros: list = None, payloads: list = None) -> dict:
    """
    Realiza fuzzing de parámetros web con diferentes payloads.
    
    Args:
        url: URL base para fuzzing
        parametros: Lista de parámetros a probar
        payloads: Lista de payloads a usar
        
    Returns:
        Diccionario con resultados del fuzzing
    """
    if parametros is None:
        parametros = ["id", "user", "page", "file", "cmd", "search", "q", "name", "email", "password"]
    
    if payloads is None:
        payloads = [
            "admin", "test", "1", "0", "-1", "999999",
            "../etc/passwd", "' OR '1'='1", "<script>alert(1)</script>",
            "$(whoami)", "; ls -la", "{{7*7}}", "${7*7}"
        ]
    
    FINDINGS.append(f"[PARAM_FUZZ] Iniciando fuzzing de parámetros en {url}")
    
    resultados = {
        "responses": [],
        "errors": [],
        "interesting": []
    }
    
    try:
        # Obtener respuesta base
        base_response = requests.get(url, timeout=5)
        base_length = len(base_response.text)
        base_status = base_response.status_code
        
        for param in parametros:
            for payload in payloads:
                try:
                    # Construir URL con parámetro
                    test_url = f"{url}?{param}={payload}"
                    response = requests.get(test_url, timeout=3)
                    
                    resultado = {
                        "url": test_url,
                        "param": param,
                        "payload": payload,
                        "status": response.status_code,
                        "length": len(response.text),
                        "time": response.elapsed.total_seconds()
                    }
                    
                    resultados["responses"].append(resultado)
                    
                    # Detectar respuestas interesantes
                    if (response.status_code != base_status or 
                        abs(len(response.text) - base_length) > 100):
                        
                        resultados["interesting"].append(resultado)
                        FINDINGS.append(f"[PARAM_INTERESTING] {test_url} - Status: {response.status_code}, Length: {len(response.text)}")
                    
                    # Buscar errores o información sensible
                    error_patterns = [
                        "error", "exception", "warning", "fatal", "mysql", "postgresql",
                        "oracle", "sqlite", "stack trace", "debug", "root:", "uid="
                    ]
                    
                    response_lower = response.text.lower()
                    for pattern in error_patterns:
                        if pattern in response_lower:
                            FINDINGS.append(f"[PARAM_ERROR] Patrón '{pattern}' encontrado en {test_url}")
                            break
                    
                    # Pequeña pausa para no sobrecargar el servidor
                    time.sleep(0.1)
                    
                except requests.RequestException as e:
                    resultados["errors"].append({
                        "param": param,
                        "payload": payload,
                        "error": str(e)
                    })
                except Exception as e:
                    logger.debug(f"Error en fuzzing: {e}")
                    continue
    
    except Exception as e:
        FINDINGS.append(f"[PARAM_FUZZ_ERROR] Error en fuzzing de parámetros: {e}")
        logger.error(f"Error en param fuzzing: {e}")
    
    FINDINGS.append(f"[PARAM_FUZZ_RESULT] {len(resultados['responses'])} requests enviados, {len(resultados['interesting'])} respuestas interesantes")
    
    return resultados


def escaneo_completo_pentesting(target: str) -> dict:
    """
    Realiza un escaneo completo de pentesting combinando todas las herramientas.
    
    Args:
        target: URL o IP objetivo
        
    Returns:
        Diccionario con todos los resultados
    """
    FINDINGS.append(f"[PENTEST_FULL] Iniciando escaneo completo de {target}")
    
    resultados = {
        "target": target,
        "timestamp": datetime.now().isoformat(),
        "port_scan": None,
        "ssl_analysis": None,
        "vulnerability_scan": None,
        "parameter_fuzzing": None
    }
    
    try:
        # Determinar si es URL o IP
        if target.startswith(('http://', 'https://')):
            parsed = urlparse(target)
            hostname = parsed.hostname
            is_https = parsed.scheme == 'https'
            
            # Escaneo de puertos
            if hostname:
                resultados["port_scan"] = escanear_puertos(hostname)
            
            # Análisis SSL si es HTTPS
            if is_https and hostname:
                resultados["ssl_analysis"] = analizar_certificado_ssl(hostname)
            
            # Detección de vulnerabilidades web
            resultados["vulnerability_scan"] = detectar_vulnerabilidades_web(target)
            
            # Fuzzing de parámetros
            resultados["parameter_fuzzing"] = fuzzing_parametros_web(target)
            
        else:
            # Asumir que es una IP o hostname
            resultados["port_scan"] = escanear_puertos(target)
            
            # Intentar análisis SSL en puerto 443
            try:
                resultados["ssl_analysis"] = analizar_certificado_ssl(target)
            except:
                pass
    
    except Exception as e:
        FINDINGS.append(f"[PENTEST_ERROR] Error en escaneo completo: {e}")
        logger.error(f"Error en pentest completo: {e}")
    
    FINDINGS.append(f"[PENTEST_COMPLETE] Escaneo completo finalizado para {target}")
    return resultados